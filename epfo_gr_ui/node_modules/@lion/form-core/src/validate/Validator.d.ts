/**
 * @typedef {object} MessageData
 * @property {*} [MessageData.modelValue]
 * @property {string} [MessageData.fieldName]
 * @property {HTMLElement} [MessageData.formControl]
 * @property {string} [MessageData.type]
 * @property {Object.<string,?>} [MessageData.config]
 * @property {string} [MessageData.name]
 */
export class Validator {
    static get validatorName(): string;
    static get async(): boolean;
    /**
     * @overridable
     * @param {MessageData} [data]
     * @returns {Promise<string|Node>}
     */
    static getMessage(data?: MessageData | undefined): Promise<string | Node>;
    /**
     *
     * @param {?} [param]
     * @param {Object.<string,?>} [config]
     */
    constructor(param?: unknown, config?: {
        [x: string]: any;
    } | undefined);
    /** @type {?} */
    __param: unknown;
    /** @type {Object.<string,?>} */
    __config: {
        [x: string]: unknown;
    };
    type: any;
    /**
     * @desc The function that returns a Boolean
     * @param {?} [modelValue]
     * @param {?} [param]
     * @param {{}} [config]
     * @returns {Boolean|Promise<Boolean>}
     */
    execute(modelValue?: unknown, param?: unknown, config?: {} | undefined): boolean | Promise<boolean>;
    set param(arg: any);
    get param(): any;
    set config(arg: {
        [x: string]: any;
    });
    get config(): {
        [x: string]: any;
    };
    /**
     * @overridable
     * @param {MessageData} [data]
     * @returns {Promise<string|Node>}
     * @protected
     */
    protected _getMessage(data?: MessageData | undefined): Promise<string | Node>;
    /**
     * @param {HTMLElement} formControl
     */
    onFormControlConnect(formControl: HTMLElement): void;
    /**
     * @param {HTMLElement} formControl
     */
    onFormControlDisconnect(formControl: HTMLElement): void;
    /**
     * @desc Used on async Validators, makes it able to do perf optimizations when there are
     * pending "execute" calls with outdated values.
     * ValidateMixin calls Validator.abortExecution() an async Validator can act accordingly,
     * depending on its implementation of the "execute" function.
     * - For instance, when fetch was called:
     * https://stackoverflow.com/questions/31061838/how-do-i-cancel-an-http-fetch-request
     * - Or, when a webworker was started, its process could be aborted and then restarted.
     */
    abortExecution(): void;
    /**
     * @private
     */
    private __fakeExtendsEventTarget;
    addEventListener: ((type: string, listener: EventListener, opts?: Object | undefined) => void) | undefined;
    removeEventListener: ((type: string, listener: EventListener, opts?: Object | undefined) => void) | undefined;
    dispatchEvent: ((event: Event | CustomEvent) => boolean) | undefined;
}
export type MessageData = {
    modelValue?: any;
    fieldName?: string;
    formControl?: HTMLElement;
    type?: string;
    config?: {
        [x: string]: unknown;
    };
    name?: string;
};

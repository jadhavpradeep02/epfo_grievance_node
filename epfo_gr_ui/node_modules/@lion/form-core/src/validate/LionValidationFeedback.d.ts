/**
 * @typedef {import('../validate/Validator').Validator} Validator
 * @typedef {import('@lion/core').TemplateResult} TemplateResult
 * @typedef {Object} messageMap
 * @property {string | Node} message
 * @property {string} type
 * @property {Validator} [validator]
 */
/**
 * @desc Takes care of accessible rendering of error messages
 * Should be used in conjunction with FormControl having ValidateMixin applied
 */
export class LionValidationFeedback extends LitElement {
    static get properties(): {
        feedbackData: {
            attribute: boolean;
        };
    };
    /**
     * @overridable
     * @param {Object} opts
     * @param {string | Node | TemplateResult } opts.message message or feedback node or TemplateResult
     * @param {string} [opts.type]
     * @param {Validator} [opts.validator]
     * @protected
     */
    protected _messageTemplate({ message }: {
        message: string | Node | TemplateResult;
        type: string;
        validator: Validator;
    }): string | Node | import("@lion/core").TemplateResult<1 | 2>;
    currentType: string | undefined;
    removeMessage: number | undefined;
    /** @type {messageMap[]} */
    feedbackData: messageMap[] | undefined;
}
export type Validator = import("./Validator").Validator;
export type TemplateResult = {
    _$litType$: 1 | 2;
    strings: TemplateStringsArray;
    values: unknown[];
};
export type messageMap = {
    message: string | Node;
    type: string;
    validator?: Validator;
};
import { LitElement } from "@lion/core";
